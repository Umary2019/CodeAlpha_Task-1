'use strict';

/**
 * Create a new instance
 */
function Kareem() {
  this._pres = new Map();
  this._posts = new Map();
}

Kareem.skipWrappedFunction = function skipWrappedFunction() {
  if (!(this instanceof Kareem.skipWrappedFunction)) {
    return new Kareem.skipWrappedFunction(...arguments);
  }

  this.args = [...arguments];
};

Kareem.overwriteResult = function overwriteResult() {
  if (!(this instanceof Kareem.overwriteResult)) {
    return new Kareem.overwriteResult(...arguments);
  }

  this.args = [...arguments];
};

/**
 * Execute all "pre" hooks for "name"
 * @param {String} name The hook name to execute
 * @param {*} context Overwrite the "this" for the hook
 * @param {Array|Function} args Optional arguments or directly the callback
 * @param {Function} [callback] The callback to call when executing all hooks are finished
 * @returns {void}
 */
Kareem.prototype.execPre = function(name, context, args, callback) {
  if (arguments.length === 3) {
    callback = args;
    args = [];
  }
  const pres = this._pres.get(name) || [];
  const numPres = pres.length;
  const numAsyncPres = pres.numAsync || 0;
  let currentPre = 0;
  let asyncPresLeft = numAsyncPres;
  let done = false;
  const $args = args;
  let shouldSkipWrappedFunction = null;

  if (!numPres) {
    return nextTick(function() {
      callback(null);
    });
  }

  function next() {
    if (currentPre >= numPres) {
      return;
    }
    const pre = pres[currentPre];

    if (pre.isAsync) {
      const args = [
        decorateNextFn(_next),
        decorateNextFn(function(error) {
          if (error) {
            if (done) {
              return;
            }
            if (error instanceof Kareem.skipWrappedFunction) {
              shouldSkipWrappedFunction = error;
            } else {
              done = true;
              return callback(error);
            }
          }
          if (--asyncPresLeft === 0 && currentPre >= numPres) {
            return callback(shouldSkipWrappedFunction);
          }
        })
      ];

      callMiddlewareFunction(pre.fn, context, args, args[0]);
    } else if (pre.fn.length > 0) {
      const args = [decorateNextFn(_next)];
      const _args = arguments.length >= 2 ? arguments : [null].concat($args);
      for (let i = 1; i < _args.length; ++i) {
        if (i === _args.length - 1 && typeof _args[i] === 'function') {
          continue; // skip callbacks to avoid accidentally calling the callback from a hook
        }
        args.push(_args[i]);
      }

      callMiddlewareFunction(pre.fn, context, args, args[0]);
    } else {
      let maybePromiseLike = null;
      try {
        maybePromiseLike = pre.fn.call(context);
      } catch (err) {
        if (err != null) {
          return callback(err);
        }
      }

      if (isPromiseLike(maybePromiseLike)) {
        maybePromiseLike.then(() => _next(), err => _next(err));
      } else {
        if (++currentPre >= numPres) {
          if (asyncPresLeft > 0) {
            // Leave parallel hooks to run
            return;
          } else {
            return nextTick(function() {
              callback(shouldSkipWrappedFunction);
            });
          }
        }
        next();
      }
    }
  }

  next.apply(null, [null].concat(args));

  function _next(error) {
    if (error) {
      if (done) {
        return;
      }
      if (error instanceof Kareem.skipWrappedFunction) {
        shouldSkipWrappedFunction = error;
      } else {
        done = true;
        return callback(error);
      }
    }

    if (++currentPre >= numPres) {
      if (asyncPresLeft > 0) {
        // Leave parallel hooks to run
        return;
      } else {
        return callback(shouldSkipWrappedFunction);
      }
    }

    next.apply(context, arguments);
  }
};

/**
 * Execute all "pre" hooks for "name" synchronously
 * @param {String} name The hook name to execute
 * @param {*} context Overwrite the "this" for the hook
 * @param {Array} [args] Apply custom arguments to the hook
 * @returns {void}
 */
Kareem.prototype.execPreSync = function(name, context, args) {
  const pres = this._pres.get(name) || [];
  const numPres = pres.length;

  for (let i = 0; i < numPres; ++i) {
    pres[i].fn.apply(context, args || []);
  }
};

/**
 * Execute all "post" hooks for "name"
 * @param {String} name The hook name to execute
 * @param {*} context Overwrite the "this" for the hook
 * @param {Array|Function} args Apply custom arguments to the hook
 * @param {*} options Optional options or directly the callback
 * @param {Function} [callback] The callback to call when executing all hooks are finished
 * @returns {void}
 */
Kareem.prototype.execPost = function(name, context, args, options, callback) {
  if (arguments.length < 5) {
    callback = options;
    options = null;
  }
  const posts = this._posts.get(name) || [];
  const numPosts = posts.length;
  let currentPost = 0;

  let firstError = null;
  if (options && options.error) {
    firstError = options.error;
  }

  if (!numPosts) {
    return nextTick(function() {
      callback.apply(null, [firstError].concat(args));
    });
  }

  function next() {
    const post = posts[currentPost].fn;
    let numArgs = 0;
    const argLength = args.length;
    const newArgs = [];
    for (let i = 0; i < argLength; ++i) {
      numArgs += args[i] && args[i]._kareemIgnore ? 0 : 1;
      if (!args[i] || !args[i]._kareemIgnore) {
        newArgs.push(args[i]);
      }
    }

    if (firstError) {
      if (isErrorHandlingMiddleware(posts[currentPost], numArgs)) {
        const _cb = decorateNextFn(function(error) {
          if (error) {
            if (error instanceof Kareem.overwriteResult) {
              args = error.args;
              if (++currentPost >= numPosts) {
                return callback.call(null, firstError);
              }
              return next();
            }
            firstError = error;
          }
          if (++currentPost >= numPosts) {
            return callback.call(null, firstError);
          }
          next();
        });

        callMiddlewareFunction(post, context,
          [firstError].concat(newArgs).concat([_cb]), _cb);
      } else {
        if (++currentPost >= numPosts) {
          return callback.call(null, firstError);
        }
        next();
      }
    } else {
      const _cb = decorateNextFn(function(error) {
        if (error) {
          if (error instanceof Kareem.overwriteResult) {
            args = error.args;
            if (++currentPost >= numPosts) {
              return callback.apply(null, [null].concat(args));
            }
            return next();
          }
          firstError = error;
          return next();
        }

        if (++currentPost >= numPosts) {
          return callback.apply(null, [null].concat(args));
        }

        next();
      });

      if (isErrorHandlingMiddleware(posts[currentPost], numArgs)) {
        // Skip error handlers if no error
        if (++currentPost >= numPosts) {
          return callback.apply(null, [null].concat(args));
        }
        return next();
      }
      if (post.length === numArgs + 1) {
        callMiddlewareFunction(post, context, newArgs.concat([_cb]), _cb);
      } else {
        let error;
        let maybePromiseLike;
        try {
          maybePromiseLike = post.apply(context, newArgs);
        } catch (err) {
          error = err;
          firstError = err;
        }

        if (isPromiseLike(maybePromiseLike)) {
          return maybePromiseLike.then(
            (res) => {
              _cb(res instanceof Kareem.overwriteResult ? res : null);
            },
            err => _cb(err)
          );
        }

        if (maybePromiseLike instanceof Kareem.overwriteResult) {
          args = maybePromiseLike.args;
        }

        if (++currentPost >= numPosts) {
          return callback.apply(null, [error].concat(args));
        }

        next();
      }
    }
  }

  next();
};

/**
 * Execute all "post" hooks for "name" synchronously
 * @param {String} name The hook name to execute
 * @param {*} context Overwrite the "this" for the hook
 * @param {Array|Function} args Apply custom arguments to the hook
 * @returns {Array} The used arguments
 */
Kareem.prototype.execPostSync = function(name, context, args) {
  const posts = this._posts.get(name) || [];
  const numPosts = posts.length;

  for (let i = 0; i < numPosts; ++i) {
    const res = posts[i].fn.apply(context, args || []);
    if (res instanceof Kareem.overwriteResult) {
      args = res.args;
    }
  }

  return args;
};

/**
 * Create a synchronous wrapper for "fn"
 * @param {String} name The name of the hook
 * @param {Function} fn The function to wrap
 * @returns {Function} The wrapped function
 */
Kareem.prototype.createWrapperSync = function(name, fn) {
  const _this = this;
  return function syncWrapper() {
    _this.execPreSync(name, this, arguments);

    const toReturn = fn.apply(this, arguments);

    const result = _this.execPostSync(name, this, [toReturn]);

    return result[0];
  };
};

function _handleWrapError(instance, error, name, context, args, options, callback) {
  if (options.useErrorHandlers) {
    return instance.execPost(name, context, args, { error: error }, function(error) {
      return typeof callback === 'function' && callback(error);
    });
  } else {
    return typeof callback === 'function' && callback(error);
  }
}

/**
 * Executes pre hooks, followed by the wrapped function, followed by post hooks.
 * @param {String} name The name of the hook
 * @param {Function} fn The function for the hook
 * @param {*} context Overwrite the "this" for the hook
 * @param {Array} args Apply custom arguments to the hook
 * @param {Object} [options]
 * @param {Boolean} [options.checkForPromise]
 * @returns {void}
 */
Kareem.prototype.wrap = function(name, fn, context, args, options) {
  const lastArg = (args.length > 0 ? args[args.length - 1] : null);
  const argsWithoutCb = Array.from(args);
  typeof lastArg === 'function' && argsWithoutCb.pop();
  const _this = this;

  options = options || {};
  const checkForPromise = options.